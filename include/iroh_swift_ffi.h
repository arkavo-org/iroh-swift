/* Auto-generated by cbindgen. Do not edit. */

#ifndef IROH_SWIFT_H
#define IROH_SWIFT_H

/* Warning: this file is auto-generated by cbindgen */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Share mode for document tickets.
 */
typedef enum IrohDocShareMode {
    /**
     * Read-only access.
     */
    Read = 0,
    /**
     * Read and write access.
     */
    Write = 1,
} IrohDocShareMode;

/**
 * Document event types.
 */
typedef enum IrohDocEventType {
    /**
     * A local insertion.
     */
    InsertLocal = 0,
    /**
     * Received a remote insert.
     */
    InsertRemote = 1,
    /**
     * Content is now available locally.
     */
    ContentReady = 2,
    /**
     * All pending content is ready.
     */
    PendingContentReady = 3,
    /**
     * A new neighbor joined the swarm.
     */
    NeighborUp = 4,
    /**
     * A neighbor left the swarm.
     */
    NeighborDown = 5,
    /**
     * Sync finished with a peer.
     */
    SyncFinished = 6,
} IrohDocEventType;

/**
 * Blob format for tickets and tags.
 */
typedef enum IrohBlobFormat {
    /**
     * Raw single blob.
     */
    Raw = 0,
    /**
     * Hash sequence (collection of blobs).
     */
    HashSeq = 1,
} IrohBlobFormat;

/**
 * Configuration for creating a node.
 */
typedef struct IrohNodeConfig {
    /**
     * Path to the blob store directory (required).
     */
    const char *storage_path;
    /**
     * Whether to use relay servers (default: true).
     */
    bool relay_enabled;
    /**
     * Custom relay URL (null to use n0's public relays).
     * Must be a valid URL like "https://relay.example.com".
     */
    const char *custom_relay_url;
    /**
     * Whether to enable the Docs engine (default: false).
     * When enabled, the node can create, join, and sync documents.
     */
    bool docs_enabled;
} IrohNodeConfig;

/**
 * Opaque handle to an Iroh node.
 *
 * The actual IrohNode is stored in a Box, and this handle holds
 * a raw pointer to that Box.
 */
typedef struct IrohNodeHandle {
    uint8_t _private[0];
} IrohNodeHandle;

/**
 * Callback for node creation.
 */
typedef struct IrohNodeCreateCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with the node handle.
     */
    void (*on_success)(void *userdata, struct IrohNodeHandle *handle);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohNodeCreateCallback;

/**
 * Borrowed bytes from Swift (read-only view into Swift memory).
 */
typedef struct IrohBytes {
    const uint8_t *data;
    uintptr_t len;
} IrohBytes;

/**
 * Callback for operations that return a string on success.
 *
 * NOTE: Callbacks run on a Tokio worker thread. Swift must safely
 * resume continuations from that context.
 */
typedef struct IrohCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with a C string (caller must free with `iroh_string_free`).
     */
    void (*on_success)(void *userdata, const char *result);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohCallback;

/**
 * Owned bytes returned to Swift (must be freed with `iroh_bytes_free`).
 */
typedef struct IrohOwnedBytes {
    uint8_t *data;
    uintptr_t len;
    uintptr_t capacity;
} IrohOwnedBytes;

/**
 * Callback for operations that return bytes on success.
 */
typedef struct IrohGetCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with owned bytes (caller must free with `iroh_bytes_free`).
     */
    void (*on_success)(void *userdata, struct IrohOwnedBytes bytes);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohGetCallback;

/**
 * Progress information for a download operation.
 */
typedef struct IrohDownloadProgress {
    /**
     * Bytes downloaded so far.
     */
    uint64_t downloaded;
    /**
     * Total bytes expected (0 if unknown).
     */
    uint64_t total;
} IrohDownloadProgress;

/**
 * Callback for get operations with progress reporting.
 */
typedef struct IrohGetProgressCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called with progress updates during download.
     */
    void (*on_progress)(void *userdata, struct IrohDownloadProgress progress);
    /**
     * Called on success with owned bytes (caller must free with `iroh_bytes_free`).
     */
    void (*on_success)(void *userdata, struct IrohOwnedBytes bytes);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohGetProgressCallback;

/**
 * Information about an Iroh node.
 */
typedef struct IrohNodeInfo {
    /**
     * Node ID as a string (caller must free with `iroh_string_free`).
     */
    const char *node_id;
    /**
     * Relay URL if connected (caller must free with `iroh_string_free`).
     * Null if not connected to a relay.
     */
    const char *relay_url;
    /**
     * Whether the node is connected to the network.
     */
    bool is_connected;
} IrohNodeInfo;

/**
 * Callback for node info retrieval.
 */
typedef struct IrohNodeInfoCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with node info.
     */
    void (*on_success)(void *userdata, struct IrohNodeInfo info);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohNodeInfoCallback;

/**
 * Parsed ticket information.
 */
typedef struct IrohTicketInfo {
    /**
     * Whether the ticket is valid.
     */
    bool is_valid;
    /**
     * The blob hash as a string (caller must free with `iroh_string_free`).
     * Null if invalid.
     */
    const char *hash;
    /**
     * The node ID from the ticket (caller must free with `iroh_string_free`).
     * Null if invalid.
     */
    const char *node_id;
    /**
     * Whether this is a recursive (collection) ticket.
     */
    bool is_recursive;
} IrohTicketInfo;

/**
 * Callback for ticket validation.
 */
typedef struct IrohTicketValidateCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called with validation result. Always called (never fails).
     */
    void (*on_complete)(void *userdata, struct IrohTicketInfo info);
} IrohTicketValidateCallback;

/**
 * Callback for node close operation.
 */
typedef struct IrohCloseCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called when close completes successfully.
     */
    void (*on_complete)(void *userdata);
    /**
     * Called if close fails with an error message.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohCloseCallback;

/**
 * Options for put/get operations.
 */
typedef struct IrohOperationOptions {
    /**
     * Timeout in milliseconds (0 = no timeout).
     */
    uint64_t timeout_ms;
} IrohOperationOptions;

/**
 * Author secret key (32 bytes).
 *
 * This is the private key material used for signing document entries.
 * Must be kept secure (e.g., in iOS Keychain).
 */
typedef struct IrohAuthorSecret {
    uint8_t bytes[32];
} IrohAuthorSecret;

/**
 * Author public ID (32 bytes).
 *
 * This is the public identifier derived from the secret key.
 * Safe to share and store openly.
 */
typedef struct IrohAuthorId {
    uint8_t bytes[32];
} IrohAuthorId;

/**
 * Callback for author creation.
 */
typedef struct IrohAuthorCreateCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with the author secret and ID.
     */
    void (*on_success)(void *userdata, struct IrohAuthorSecret secret, struct IrohAuthorId id);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohAuthorCreateCallback;

/**
 * Opaque handle to an Iroh document.
 *
 * Documents are syncing key-value stores shared between peers.
 * The handle wraps a Doc from iroh-docs.
 */
typedef struct IrohDocHandle {
    uint8_t _private[0];
} IrohDocHandle;

/**
 * Callback for document creation/join operations.
 */
typedef struct IrohDocCreateCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with the document handle and namespace ID.
     */
    void (*on_success)(void *userdata, struct IrohDocHandle *handle, const char *namespace_id);
    /**
     * Called on failure with an error message (caller must free with `iroh_string_free`).
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocCreateCallback;

/**
 * Callback for document set operations.
 */
typedef struct IrohDocSetCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with the content hash (caller must free with `iroh_string_free`).
     */
    void (*on_success)(void *userdata, const char *hash);
    /**
     * Called on failure with an error message.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocSetCallback;

/**
 * A document entry (key-value pair with metadata).
 */
typedef struct IrohDocEntry {
    /**
     * Author ID who wrote this entry (32 bytes).
     */
    struct IrohAuthorId author_id;
    /**
     * Key bytes (owned, must be freed).
     */
    struct IrohOwnedBytes key;
    /**
     * Content hash as hex string (must be freed with `iroh_string_free`).
     */
    char *content_hash;
    /**
     * Size of the content in bytes.
     */
    uint64_t content_size;
    /**
     * Timestamp when entry was created (microseconds since epoch).
     */
    uint64_t timestamp;
} IrohDocEntry;

/**
 * Callback for document get operations.
 */
typedef struct IrohDocGetCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with the entry (may be null if not found).
     * Caller must free entry with `iroh_doc_entry_free` if not null.
     */
    void (*on_success)(void *userdata, const struct IrohDocEntry *entry);
    /**
     * Called on failure with an error message.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocGetCallback;

/**
 * Streaming callback for get_many (prefix queries).
 * Called multiple times - once per entry, then on_complete.
 */
typedef struct IrohDocGetManyCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called for each entry found. Entry must be freed with `iroh_doc_entry_free`.
     */
    void (*on_entry)(void *userdata, const struct IrohDocEntry *entry);
    /**
     * Called when iteration completes successfully.
     */
    void (*on_complete)(void *userdata);
    /**
     * Called on error. No more callbacks after this.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocGetManyCallback;

/**
 * Callback for document delete operations.
 */
typedef struct IrohDocDelCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called on success with count of deleted entries.
     */
    void (*on_success)(void *userdata, uint64_t deleted_count);
    /**
     * Called on failure with an error message.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocDelCallback;

/**
 * Opaque handle to a document subscription.
 *
 * Used to cancel an active subscription.
 */
typedef struct IrohSubscriptionHandle {
    uint8_t _private[0];
} IrohSubscriptionHandle;

/**
 * A document event from subscription.
 */
typedef struct IrohDocEvent {
    /**
     * The type of event.
     */
    enum IrohDocEventType event_type;
    /**
     * The entry for insert events (null for other events).
     * Must be freed with `iroh_doc_entry_free` if not null.
     */
    const struct IrohDocEntry *entry;
    /**
     * The peer ID for remote events (null for local events).
     * Must be freed with `iroh_string_free` if not null.
     */
    const char *peer_id;
    /**
     * The content hash for ContentReady events (null for other events).
     * Must be freed with `iroh_string_free` if not null.
     */
    const char *content_hash;
} IrohDocEvent;

/**
 * Streaming callback for document subscriptions.
 * Called multiple times - once per event, then on_complete when stream ends.
 */
typedef struct IrohDocSubscribeCallback {
    /**
     * Opaque pointer passed back to Swift.
     */
    void *userdata;
    /**
     * Called for each event. Event must be freed with `iroh_doc_event_free`.
     */
    void (*on_event)(void *userdata, struct IrohDocEvent event);
    /**
     * Called when subscription ends normally.
     */
    void (*on_complete)(void *userdata);
    /**
     * Called on error. No more callbacks after this.
     */
    void (*on_failure)(void *userdata, const char *error);
} IrohDocSubscribeCallback;

/**
 * Create a new Iroh node asynchronously.
 *
 * # Safety
 * - `config.storage_path` must be a valid null-terminated UTF-8 string
 * - `config.custom_relay_url` must be null or a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_node_create(struct IrohNodeConfig config, struct IrohNodeCreateCallback callback);

/**
 * Destroy an Iroh node and free its resources.
 *
 * This performs a graceful shutdown, ensuring pending writes are flushed.
 *
 * # Safety
 * - `handle` must be a valid pointer returned by `iroh_node_create`
 * - `handle` must not be used after this call
 */
void iroh_node_destroy(struct IrohNodeHandle *handle);

/**
 * Add bytes to the blob store and get a shareable ticket.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `bytes.data` must point to valid memory for `bytes.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_put(const struct IrohNodeHandle *handle,
              struct IrohBytes bytes,
              struct IrohCallback callback);

/**
 * Download bytes from a ticket.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `ticket` must be a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_get(const struct IrohNodeHandle *handle,
              const char *ticket,
              struct IrohGetCallback callback);

/**
 * Free a string returned by Iroh functions.
 *
 * # Safety
 * - `s` must be a pointer returned by an Iroh function, or null
 * - `s` must not be used after this call
 */
void iroh_string_free(char *s);

/**
 * Free bytes returned by `iroh_get`.
 *
 * # Safety
 * - `bytes` must have been returned by `iroh_get`
 * - The bytes must not be used after this call
 */
void iroh_bytes_free(struct IrohOwnedBytes bytes);

/**
 * Download bytes from a ticket with progress reporting.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `ticket` must be a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_get_with_progress(const struct IrohNodeHandle *handle,
                            const char *ticket,
                            struct IrohGetProgressCallback callback);

/**
 * Get information about the node.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `callback` must have valid function pointers
 */
void iroh_node_info(const struct IrohNodeHandle *handle, struct IrohNodeInfoCallback callback);

/**
 * Validate and parse a ticket string.
 *
 * This function always succeeds - check `info.is_valid` for the result.
 *
 * # Safety
 * - `ticket` must be a valid null-terminated UTF-8 string (or null)
 * - `callback` must have valid function pointers
 */
void iroh_validate_ticket(const char *ticket, struct IrohTicketValidateCallback callback);

/**
 * Explicitly close a node and free its resources asynchronously.
 *
 * This is preferred over `iroh_node_destroy` when you need to await
 * graceful shutdown completion.
 *
 * # Safety
 * - `handle` must be a valid pointer returned by `iroh_node_create`
 * - `handle` must not be used after this call
 * - `callback` must have valid function pointers
 */
void iroh_node_close(struct IrohNodeHandle *handle, struct IrohCloseCallback callback);

/**
 * Add bytes to the blob store with options (e.g., timeout).
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `bytes.data` must point to valid memory for `bytes.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_put_with_options(const struct IrohNodeHandle *handle,
                           struct IrohBytes bytes,
                           struct IrohOperationOptions options,
                           struct IrohCallback callback);

/**
 * Download bytes from a ticket with options (e.g., timeout).
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `ticket` must be a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_get_with_options(const struct IrohNodeHandle *handle,
                           const char *ticket,
                           struct IrohOperationOptions options,
                           struct IrohGetCallback callback);

/**
 * Create a new random author keypair.
 *
 * The secret key should be stored securely (e.g., in iOS Keychain).
 * The ID is derived from the secret and can be stored openly.
 *
 * # Safety
 * - `callback` must have valid function pointers
 */
void iroh_author_create(struct IrohAuthorCreateCallback callback);

/**
 * Get the author ID from a secret key.
 *
 * This is a pure computation - no node required.
 * Useful for deriving the ID after loading secret from Keychain.
 *
 * # Safety
 * - `secret` must contain valid author secret bytes
 */
struct IrohAuthorId iroh_author_id_from_secret(struct IrohAuthorSecret secret);

/**
 * Import an author from a hex-encoded secret key.
 *
 * Useful for debugging or cross-device sync.
 *
 * # Safety
 * - `secret_hex` must be a valid null-terminated UTF-8 string containing 64 hex chars
 * - `callback` must have valid function pointers
 */
void iroh_author_from_hex(const char *secretHex, struct IrohAuthorCreateCallback callback);

/**
 * Export an author secret as a hex string.
 *
 * Useful for debugging or backup.
 *
 * # Safety
 * - The returned string must be freed with `iroh_string_free`
 */
char *iroh_author_secret_to_hex(struct IrohAuthorSecret secret);

/**
 * Export an author ID as a hex string.
 *
 * # Safety
 * - The returned string must be freed with `iroh_string_free`
 */
char *iroh_author_id_to_hex(struct IrohAuthorId id);

/**
 * Import an author into the docs engine.
 *
 * This must be called before using an author to sign document entries.
 * The author is registered with the docs engine so it can sign entries.
 *
 * # Safety
 * - `handle` must be a valid node handle with docs enabled
 * - `callback` must have valid function pointers
 */
void iroh_author_import(const struct IrohNodeHandle *handle,
                        struct IrohAuthorSecret authorSecret,
                        struct IrohCloseCallback callback);

/**
 * Create a new document.
 *
 * # Safety
 * - `handle` must be a valid node handle with docs enabled
 * - `callback` must have valid function pointers
 */
void iroh_doc_create(const struct IrohNodeHandle *handle, struct IrohDocCreateCallback callback);

/**
 * Join an existing document via ticket.
 *
 * # Safety
 * - `handle` must be a valid node handle with docs enabled
 * - `ticket` must be a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_doc_join(const struct IrohNodeHandle *handle,
                   const char *ticket,
                   struct IrohDocCreateCallback callback);

/**
 * Set a key-value pair in a document.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `key.data` must point to valid memory for `key.len` bytes
 * - `value.data` must point to valid memory for `value.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_doc_set(const struct IrohDocHandle *docHandle,
                  struct IrohAuthorSecret authorSecret,
                  struct IrohBytes key,
                  struct IrohBytes value,
                  struct IrohDocSetCallback callback);

/**
 * Get the latest entry for a key.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `key.data` must point to valid memory for `key.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_doc_get(const struct IrohDocHandle *docHandle,
                  struct IrohBytes key,
                  struct IrohDocGetCallback callback);

/**
 * Get entries by key prefix.
 *
 * This streams entries back via the callback - on_entry is called for each
 * entry, then on_complete when done.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `prefix.data` must point to valid memory for `prefix.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_doc_get_many(const struct IrohDocHandle *docHandle,
                       struct IrohBytes prefix,
                       struct IrohDocGetManyCallback callback);

/**
 * Delete an entry (creates a tombstone).
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `key.data` must point to valid memory for `key.len` bytes
 * - `callback` must have valid function pointers
 */
void iroh_doc_del(const struct IrohDocHandle *docHandle,
                  struct IrohAuthorSecret authorSecret,
                  struct IrohBytes key,
                  struct IrohDocDelCallback callback);

/**
 * Read content bytes by hash.
 *
 * This fetches the actual content data for an entry (entries only contain the hash).
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `content_hash` must be a valid null-terminated UTF-8 hex string
 * - `callback` must have valid function pointers
 */
void iroh_doc_read_content(const struct IrohNodeHandle *handle,
                           const char *contentHash,
                           struct IrohGetCallback callback);

/**
 * Get a share ticket for a document.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `callback` must have valid function pointers
 */
void iroh_doc_share(const struct IrohDocHandle *docHandle,
                    enum IrohDocShareMode mode,
                    struct IrohCallback callback);

/**
 * Close a document and free its resources.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle returned by `iroh_doc_create` or `iroh_doc_join`
 * - `doc_handle` must not be used after this call
 */
void iroh_doc_close(struct IrohDocHandle *docHandle);

/**
 * Free a document entry.
 *
 * # Safety
 * - `entry` must be a valid entry pointer returned by document operations
 * - `entry` must not be used after this call
 */
void iroh_doc_entry_free(struct IrohDocEntry *entry);

/**
 * Subscribe to document events.
 *
 * Returns a subscription handle that can be used to cancel the subscription.
 * Events are delivered via the callback until the subscription is cancelled
 * or the stream ends.
 *
 * # Safety
 * - `doc_handle` must be a valid document handle
 * - `callback` must have valid function pointers that remain valid for the
 *   duration of the subscription
 */
struct IrohSubscriptionHandle *iroh_doc_subscribe(const struct IrohDocHandle *docHandle,
                                                  struct IrohDocSubscribeCallback callback);

/**
 * Cancel an active subscription.
 *
 * After calling this, no more events will be delivered and on_complete will be called.
 *
 * # Safety
 * - `handle` must be a valid subscription handle returned by `iroh_doc_subscribe`
 * - `handle` must not be used after this call
 */
void iroh_subscription_cancel(struct IrohSubscriptionHandle *handle);

/**
 * Free a document event.
 *
 * # Safety
 * - `event` fields that are non-null must be valid pointers
 */
void iroh_doc_event_free(struct IrohDocEvent event);

/**
 * Tag (pin) a blob to prevent garbage collection.
 *
 * Tagged blobs are protected from GC until the tag is removed.
 * Use this after downloading content you want to keep.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `tag_name` must be a valid null-terminated UTF-8 string
 * - `hash_str` must be a valid null-terminated hex hash string
 * - `callback` must have valid function pointers
 */
void iroh_blob_tag_set(const struct IrohNodeHandle *handle,
                       const char *tagName,
                       const char *hashStr,
                       enum IrohBlobFormat format,
                       struct IrohCloseCallback callback);

/**
 * Create a shareable ticket for an existing local blob.
 *
 * The ticket points to this node as the provider.
 * Use this to "mint" a bootstrap ticket after downloading content.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `hash_str` must be a valid null-terminated hex hash string
 * - `callback` must have valid function pointers
 */
void iroh_blob_ticket_create(const struct IrohNodeHandle *handle,
                             const char *hashStr,
                             enum IrohBlobFormat format,
                             struct IrohCallback callback);

/**
 * Remove a tag (unpin) from a blob, allowing garbage collection.
 *
 * # Safety
 * - `handle` must be a valid node handle
 * - `tag_name` must be a valid null-terminated UTF-8 string
 * - `callback` must have valid function pointers
 */
void iroh_blob_tag_delete(const struct IrohNodeHandle *handle,
                          const char *tagName,
                          struct IrohCloseCallback callback);

#endif  /* IROH_SWIFT_H */
